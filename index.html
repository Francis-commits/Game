<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Logic Quest - The Battle of Truths</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

<style>
/* --- CUSTOM CSS (KEPT FOR THEME/COLORS/ANIMATIONS) --- */
:root{
  --bg:#071033; --panel:#0f1440; --muted:#b6b8d6; --accent:#ff3d84; --accent2:#6c58ff; --gold:#ffd166;
  --ok:#36d399; --bad:#ff4747;
  --border:#2e335a;
  --btn-height:54px; /* Standard button height */
}
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: linear-gradient(180deg,#05061a 0%,#071033 100%);
  color:#fff;
  overflow: hidden;
}

/* Custom styles replacing Bootstrap defaults */
header{
  height:60px; 
  background:rgba(8,12,36,.8);
  border-bottom:1px solid rgba(255,255,255,.05);
  box-shadow:0 2px 8px rgba(0,0,0,.4); 
  z-index:20;
}
header h1{margin:0;font-size:20px}
.muted{color:var(--muted);font-size:14px} 

main{
  min-height: 100vh; /* Full viewport height for centering */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem 0;
}

/* --- GAME CARD STYLE --- */
.game-card{
  background:linear-gradient(180deg,#071033,#06102a);
  border-radius:16px; 
  max-width: 700px;
  width: 100%;
  padding: 0.75rem;
  border:1px solid var(--border);
  box-shadow:0 18px 60px rgba(0,0,0,.6);
  overflow:hidden;
  margin: auto; /* Center horizontally */
}

/* Player Card Style */
.player-card{
  font-size: 18px !important;
  max-width: 500px !important;
  padding: 0.5rem !important;
  border-radius:18px; 
  background:linear-gradient(180deg,#081236,#07102a);
  border:1px solid rgba(255,255,255,.06); 
  box-shadow:0 10px 40px rgba(0,0,0,.6)
}
.player-name{font-size:22px;font-weight:800}
.buff-pill{
  padding:8px 14px; border-radius:14px; background:rgba(255,255,255,.05); 
  border:1px solid rgba(255,255,255,.08); cursor:pointer;user-select:none; transition:background .15s
}
.buff-pill:not(.used):hover{background:rgba(255,255,255,.1)} 
.buff-pill.used{opacity:.4;text-decoration:line-through;cursor:default}
.gem{width:28px;height:28px;border-radius:50%;background:#2b2e62;border:2px solid var(--border);transition:transform .18s,box-shadow .18s}
.gem.fill{background:radial-gradient(circle,var(--accent2),var(--gold));box-shadow:0 0 16px rgba(108,88,255,.36);transform:scale(1.18)}

/* Big statement and Timer */
#expr{font-size:clamp(24px, 6vw, 72px);color:var(--gold);text-align:center;margin:1rem 0;font-weight:900;line-height:1;word-break:break-word;max-width:96%;transition:transform .12s}
#assign{color:var(--muted);font-size:16px;text-align:center}
.timer-circle{width:70px;height:70px;border-radius:50%;display:grid;place-items:center;background:conic-gradient(var(--accent2) 0deg, rgba(255,255,255,.04) 0deg);position:relative}
.timer-inner{width:56px;height:56px;border-radius:50%;background:#07102a;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px}
.timer-seconds{font-size:16px;color:var(--muted)}

/* Action Buttons */
.btn-true{background:var(--ok);color:#04120c;border:none;border-radius:16px;font-size:18px;font-weight:700;cursor:pointer;min-width:160px;height:var(--btn-height);transition:transform .15s}
.btn-true:active{transform:translateY(2px)}
.btn-false{background:var(--bad);color:#fff;border:none;border-radius:16px;font-size:18px;font-weight:700;cursor:pointer;min-width:160px;height:var(--btn-height);transition:transform .15s}
.btn-false:active{transform:translateY(2px)}
.btn-small{
  padding:0.75rem 1rem; border-radius:16px; background:rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.1); cursor:pointer; height:var(--btn-height); font-size:16px;
  transition:background .15s, transform .15s
}
.btn-small:hover{background:rgba(255,255,255,.1)}
.btn-small:active{transform:translateY(2px)}

.dot{width:14px;height:14px;border-radius:50%;background:rgba(255,255,255,.08);cursor:pointer;transition:background .15s,box-shadow .15s}
.dot.active{background:var(--gold);box-shadow:0 0 10px rgba(255,209,102,.3)}

#result{min-height:40px;margin-top:1rem;text-align:center;font-weight:800;font-size:18px}
.log{
  max-height:150px; overflow:auto; margin-top:0.75rem; padding:0.75rem; 
  border-radius:10px; background:rgba(0,0,0,.12); color:var(--muted);width:100%
}

/* Welcome Overlay */
.overlay {
  position:fixed;left:0;right:0;top:0;bottom:0;z-index:99999;
  background:linear-gradient(180deg, rgba(0,0,0,.8), rgba(0,0,0,.9));
  padding:20px;
}
.overlay.hidden{display:none!important;pointer-events:none!important}
.welcome {
  border-radius:20px; padding:1.75rem; 
  background:linear-gradient(180deg,#071033,#06102a);
  border:1px solid rgba(255,255,255,.06);
  box-shadow:0 30px 120px rgba(0,0,0,.7);
}
.brand-icon{font-size:40px;color:var(--gold);}
.brand-title{font-size:30px;color:var(--gold);font-weight:900}
.brand-sub{color:var(--muted);font-size:16px}
input[type=number], input[type=text], select{
  padding:10px; border-radius:10px; border:1px solid var(--border);
  background:rgba(255,255,255,.02); color:#fff; font-size:16px
}
.avatar{
  width:60px;height:60px; border-radius:12px; background:rgba(255,255,255,.04);
  display:flex;align-items:center;justify-content:center; font-size:32px;
  cursor:pointer; border:2px solid transparent; transition:border-color .15s,box-shadow .15s
}
.avatar.selected{border-color:var(--gold);box-shadow:0 0 12px rgba(255,209,102,.12)}
.btn-primary{
  padding:14px 22px; border-radius:12px; border:none; background:var(--accent2);
  color:#fff; font-weight:800; cursor:pointer; height:var(--btn-height); font-size:18px;
  transition:transform .15s
}
.btn-primary:active{transform:translateY(2px)}
.btn-secondary{
  padding:12px 16px; border-radius:12px; background:rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.1); color:var(--muted); cursor:pointer;
  height:var(--btn-height); font-size:16px; transition:transform .15s
}
.btn-secondary:active{transform:translateY(2px)}
.diamond{font-size:50px;display:inline-block;transform-origin:center;animation:diamond-spin 2.2s linear infinite}
.sorcerer{font-size:54px;display:inline-block;animation:sorcerer-bob 2.4s ease-in-out infinite}
@keyframes diamond-spin{0%{transform:rotate(0deg) translateY(0)}50%{transform:rotate(180deg) translateY(-6px)}100%{transform:rotate(360deg) translateY(0)}}
@keyframes sorcerer-bob{0%{transform:translateY(0) scale(1)}50%{transform:translateY(-8px) scale(1.04)}100%{transform:translateY(0) scale(1)}}

.back-btn{
  padding:10px 14px; border-radius:12px; background:rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.1); color:var(--muted); cursor:pointer; height:var(--btn-height)
}
.victory {
  position:fixed;left:50%;top:10%; transform:translateX(-50%); padding:14px 20px;
  border-radius:16px; background:linear-gradient(90deg,#ffd166,#ff3d84);
  color:#042024;font-weight:900;z-index:999999; font-size:18px;
}
.confetti-container{position:fixed;inset:0;pointer-events:none;z-index:999998;overflow:hidden}

/* Responsive adjustments */
@media (max-width: 992px) {
  .welcome .row { flex-direction: column; }
  .welcome-left { text-align: center; align-items: center !important; }
}
@media (max-width: 576px) {
  .actions .btn-true, .actions .btn-false { min-width: 48%; }
  .actions .btn-small { min-width: 30%; height: 44px; font-size: 14px; }
  .actions { gap: 8px !important; }
  :root{ --btn-height: 48px; }
}
</style>
</head>
<body>

<header class="d-flex align-items-center justify-content-between px-4">
  <h1>Logic Quest - The Battle of Truths</h1>
  <div class="top-actions d-flex align-items-center gap-3">
    <button id="backToWelcome" class="back-btn" type="button" title="Back to welcome" aria-label="Back to welcome">‚§∫ Back</button>
    <span class="d-none d-md-inline" style="color:var(--muted);font-size:13px">Hotseat ¬∑ Shortcuts: T/F/H/S ¬∑ M mute</span>
  </div>
</header>

<main class="d-flex align-items-center justify-content-center">
  <div class="game-card d-flex flex-column align-items-center" id="gameCard" aria-live="polite" aria-hidden="true" style="max-width:100%; width:96%;">
    
    <!-- Player Section -->
    <div class="player-card col-12 col-md-10 col-lg-8 mb-3 p-3 d-flex flex-column align-items-center mx-auto" id="playerCard" aria-live="polite">
      <div class="player-name" id="playerName">Player</div>
      <div class="buffs d-flex flex-wrap justify-content-center gap-2 mt-2" id="buffsArea"></div>
      <div class="gems d-flex gap-2 mt-3" id="gemsArea"></div>
      <div id="scoreArea" class="muted mt-2">Score: 0</div>
    </div>

    <!-- Main Game Display -->
    <div id="expr">Press Start</div>
    <div id="assign" class="muted"></div>

    <!-- Timer Row -->
    <div class="timer-row d-flex gap-3 align-items-center mt-3">
      <div class="timer-circle" id="timerCircle">
        <div class="timer-inner" id="timerInner">20</div>
      </div>
      <div class="timer-seconds muted" id="timerLabel">seconds</div>
    </div>

    <!-- Action Buttons -->
    <div class="actions d-flex flex-wrap justify-content-center gap-3 mt-4 w-100" style="max-width: 600px;">
      <button id="trueBtn" class="btn-true flex-grow-1">True (T)</button>
      <button id="falseBtn" class="btn-false flex-grow-1">False (F)</button>
      <button id="hintBtn" class="btn-small">Hint (H)</button>
      <button id="skipBtn" class="btn-small">Skip (S)</button>
      <button id="explainBtn" class="btn-small">Explain</button>
    </div>

    <!-- Result & Indicators -->
    <div id="result"></div>
    <div class="indicators d-flex gap-2 mt-3" id="indicators"></div>

    <!-- Log -->
    <div class="log w-100 mt-3 mx-auto" id="log" tabindex="0" style="max-width: 600px;"></div>
  </div>
</main>

<!-- Victory Banner -->
<div id="victoryBanner" class="victory" style="display:none">
  <div id="victoryText"></div>
  <button id="closeVictory" class="btn-secondary">Close</button>
</div>

<!-- Confetti -->
<div class="confetti-container" id="confetti"></div>

<!-- Welcome Overlay -->
<div class="overlay d-flex align-items-center justify-content-center" id="overlay" role="dialog" aria-modal="true" aria-label="Welcome to Logic Quest">
  <div class="welcome col-12 col-lg-10 col-xl-9 shadow" id="welcomePanel">
    <div class="row g-4">
      <!-- Left Side -->
      <div class="welcome-left col-12 col-lg-4 d-flex flex-column gap-3 align-items-lg-start">
        <div class="brand-icon d-flex gap-3 align-items-center">
          <span class="diamond" aria-hidden="true">üíé</span>
          <span class="sorcerer" aria-hidden="true">üßô‚Äç‚ôÇÔ∏è</span>
        </div>
        <div class="brand-title">Welcome to Logic Quest - The Battle of Truths</div>
        <div class="brand-sub">A tabletop-style hotseat logic game. Choose players, avatars and two one-use buffs each. The overlay covers the entire screen ‚Äî Start is always reachable.</div>
        <div class="muted mt-2">Controls: T (True), F (False), H (Hint), S (Skip), M (Mute)</div>
      </div>
      <!-- Right Side -->
      <div class="welcome-right col-12 col-lg-8 d-flex flex-column gap-3">
        <div class="setup-row d-flex gap-3 align-items-center flex-wrap">
          <label>Players</label>
          <input id="playerCount" type="number" min="1" max="4" value="2" aria-label="Number of players" style="width: 60px;">
          <label>Turn (sec)</label>
          <input id="turnTime" type="number" min="5" max="60" value="20" aria-label="Turn time" style="width: 70px;">
          <label>Target Gems</label>
          <input id="targetGems" type="number" min="1" max="9" value="5" aria-label="Target gems to win" style="width: 60px;">
        </div>
        <div class="mt-2">
          <label class="muted">Pick an avatar (applies as default for players)</label>
          <div class="avatars d-flex gap-2 flex-wrap mt-2" id="avatarsRow" aria-hidden="false"></div>
        </div>
        <div class="mt-2">
          <label class="muted">Player names & two buffs each</label>
          <div class="players-setup d-flex flex-column gap-2 mt-2" id="playersSetup"></div>
        </div>
        <div class="start-row d-flex gap-3 justify-content-end mt-2">
          <button id="startBtn" class="btn-primary" type="button">Start Game</button>
          <button id="demoBtn" class="btn-secondary" type="button">Quick 1v1</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

<script>
/*
 * Logic Quest Game Logic
 */

const CONFIG = {
    AVATARS: ['üêâ','ü¶ä','ü¶Å','ü¶Ñ','ü¶â','üêô','üß†','üõ°Ô∏è'],
    BUFFS: [
        {name:'üõ°Ô∏è Shield', key:'shield', desc:'No penalty for your next wrong answer.'},
        {name:'üîÑ Negation', key:'negate', desc:'Flip your next chosen answer.'},
        {name:'‚ö° Dash', key:'dash', desc:'Skip your turn immediately.'},
        {name:'üíé Double', key:'double', desc:'Next correct grants +2 gems.'}
    ],
    DECK: [
        // Your deck items...
        {expr:'If P is true, then Q must be true.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
        // =========================
// üî• LOGIC DECK ‚Äî 100 ITEMS
// =========================

// --- BASIC (P, Q) ---
{expr:'If P is true, then Q must be true.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
{expr:'P and Q are both true.', vars:['P','Q'], eval:v=>(v.P && v.Q)},
{expr:'At least one of P or Q is true.', vars:['P','Q'], eval:v=>(v.P || v.Q)},
{expr:'P is true, but Q is false.', vars:['P','Q'], eval:v=>(v.P && !v.Q)},
{expr:'Both P and Q are false.', vars:['P','Q'], eval:v=>(!v.P && !v.Q)},
{expr:'Exactly one of P or Q is true.', vars:['P','Q'], eval:v=>(v.P !== v.Q)},
{expr:'If P is false, the statement is automatically true.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
{expr:'P is true only if Q is true.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
{expr:'P and Q have the same truth value.', vars:['P','Q'], eval:v=>(v.P === v.Q)},
{expr:'P is true OR Q is true, but not both.', vars:['P','Q'], eval:v=>(v.P !== v.Q)},
{expr:'It is not the case that P is true.', vars:['P'], eval:v=>(!v.P)},
{expr:'It is not the case that P and Q are both true.', vars:['P','Q'], eval:v=>!(v.P && v.Q)},
{expr:'If Q is true, then P must also be true.', vars:['P','Q'], eval:v=>(!v.Q || v.P)},
{expr:'P is true, or both P and Q are false.', vars:['P','Q'], eval:v=>(v.P || (!v.P && !v.Q))},
{expr:'P is false OR Q is true.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
{expr:'If P is true, then Q must be false.', vars:['P','Q'], eval:v=>(!v.P || !v.Q)},
{expr:'P is true AND Q is not true.', vars:['P','Q'], eval:v=>(v.P && !v.Q)},
{expr:'Q is definitely true.', vars:['Q'], eval:v=>(v.Q)},
{expr:'P is false but Q is true.', vars:['P','Q'], eval:v=>(!v.P && v.Q)},
{expr:'P is true OR Q is false.', vars:['P','Q'], eval:v=>(v.P || !v.Q)},

// --- MORE BASIC (21‚Äì40) ---
{expr:'If P is true, then P or Q is true.', vars:['P','Q'], eval:v=>(!v.P || (v.P || v.Q))},
{expr:'P implies P.', vars:['P'], eval:v=>(true)},
{expr:'P implies (P and Q).', vars:['P','Q'], eval:v=>(!v.P || (v.P && v.Q))},
{expr:'P implies (P or Q).', vars:['P','Q'], eval:v=>(!v.P || (v.P || v.Q))},
{expr:'(P and Q) implies P.', vars:['P','Q'], eval:v=>(!(v.P && v.Q) || v.P)},
{expr:'(P and Q) implies Q.', vars:['P','Q'], eval:v=>(!(v.P && v.Q) || v.Q)},
{expr:'(P or Q) implies P.', vars:['P','Q'], eval:v=>(!(v.P || v.Q) || v.P)},
{expr:'(P or Q) implies Q.', vars:['P','Q'], eval:v=>(!(v.P || v.Q) || v.Q)},
{expr:'Not (P or Q).', vars:['P','Q'], eval:v=>!(v.P || v.Q)},
{expr:'Not (P implies Q).', vars:['P','Q'], eval:v=>(v.P && !v.Q)},
{expr:'Not (P and Q).', vars:['P','Q'], eval:v=>!(v.P && v.Q)},
{expr:'Not (P iff Q).', vars:['P','Q'], eval:v=>(v.P !== v.Q)},
{expr:'P iff Q.', vars:['P','Q'], eval:v=>(v.P === v.Q)},
{expr:'P or (not Q).', vars:['P','Q'], eval:v=>(v.P || !v.Q)},
{expr:'Q or (not P).', vars:['P','Q'], eval:v=>(v.Q || !v.P)},
{expr:'If P and Q are true, then P or Q is true.', vars:['P','Q'], eval:v=>(!(v.P && v.Q) || (v.P || v.Q))},
{expr:'If P is false, then Q must be true.', vars:['P','Q'], eval:v=>(v.P || v.Q)},
{expr:'P only if Q.', vars:['P','Q'], eval:v=>(!v.P || v.Q)},
{expr:'Q only if P.', vars:['P','Q'], eval:v=>(!v.Q || v.P)},
{expr:'Exactly one is false.', vars:['P','Q'], eval:v=>(v.P !== v.Q)},

// --- MEDIUM (41‚Äì60, now include R) ---
{expr:'P and Q and R are all true.', vars:['P','Q','R'], eval:v=>(v.P && v.Q && v.R)},
{expr:'At least one of P, Q, or R is true.', vars:['P','Q','R'], eval:v=>(v.P || v.Q || v.R)},
{expr:'Exactly one of P, Q, R is true.', vars:['P','Q','R'], eval:v=>[v.P,v.Q,v.R].filter(x=>x).length===1},
{expr:'Exactly two of P, Q, R are true.', vars:['P','Q','R'], eval:v=>[v.P,v.Q,v.R].filter(x=>x).length===2},
{expr:'None of P, Q, R are true.', vars:['P','Q','R'], eval:v=>(!v.P && !v.Q && !v.R)},
{expr:'If P is true, then Q and R must be true.', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q && v.R))},
{expr:'If P and Q are true, R must also be true.', vars:['P','Q','R'], eval:v=>(!(v.P && v.Q) || v.R)},
{expr:'If R is false, then P must be true.', vars:['P','Q','R'], eval:v=>(v.R || v.P)},
{expr:'P is true only if Q and R are true.', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q && v.R))},
{expr:'P or Q must be true, but R is false.', vars:['P','Q','R'], eval:v=>((v.P || v.Q) && !v.R)},
{expr:'P and not Q and R.', vars:['P','Q','R'], eval:v=>(v.P && !v.Q && v.R)},
{expr:'not P and Q and R.', vars:['P','Q','R'], eval:v=>(!v.P && v.Q && v.R)},
{expr:'P and Q imply R.', vars:['P','Q','R'], eval:v=>(!(v.P && v.Q) || v.R)},
{expr:'R implies (P or Q).', vars:['P','Q','R'], eval:v=>(!v.R || (v.P || v.Q))},
{expr:'P implies (Q iff R).', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q === v.R))},
{expr:'P iff (Q and R).', vars:['P','Q','R'], eval:v=>(v.P === (v.Q && v.R))},
{expr:'P iff (Q or R).', vars:['P','Q','R'], eval:v=>(v.P === (v.Q || v.R))},
{expr:'P xor Q xor R.', vars:['P','Q','R'], eval:v=>([v.P,v.Q,v.R].filter(x=>x).length % 2 === 1)},
{expr:'If Q is true, P must also be true, but R can be anything.', vars:['P','Q','R'], eval:v=>(!v.Q || v.P)},
{expr:'If P is false, the statement is always true.', vars:['P','Q','R'], eval:v=>(!v.P || true)},

// --- HARDER (61‚Äì80) ---
{expr:'If P is true, then at least one of Q or R must be true.', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q || v.R))},
{expr:'If Q or R is true, then P must be true.', vars:['P','Q','R'], eval:v=>(!(v.Q || v.R) || v.P)},
{expr:'If P and R are false, Q must be true.', vars:['P','Q','R'], eval:v=>((!v.P && !v.R) ? v.Q : true)},
{expr:'P is true only if exactly one of Q or R is true.', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q !== v.R))},
{expr:'If P is true, Q and R have the same value.', vars:['P','Q','R'], eval:v=>(!v.P || (v.Q === v.R))},
{expr:'P is true if and only if exactly two of Q and R are true.', vars:['P','Q','R'], eval:v=>(v.P === ([v.Q,v.R].filter(x=>x).length===2))},
{expr:'P is true if Q is false and R is true.', vars:['P','Q','R'], eval:v=>((!v.Q && v.R) ? v.P : true)},
{expr:'Not (P and (Q or R)).', vars:['P','Q','R'], eval:v=>!(v.P && (v.Q || v.R))},
{expr:'Not (P or (Q and R)).', vars:['P','Q','R'], eval:v=>!(v.P || (v.Q && v.R))},
{expr:'P implies (not Q or R).', vars:['P','Q','R'], eval:v=>(!v.P || (!v.Q || v.R))},
{expr:'(P xor Q) implies R.', vars:['P','Q','R'], eval:v=>(!(v.P !== v.Q) || v.R)},
{expr:'R implies (P and not Q).', vars:['P','Q','R'], eval:v=>(!v.R || (v.P && !v.Q))},
{expr:'P or Q, but not R.', vars:['P','Q','R'], eval:v=>((v.P || v.Q) && !v.R)},
{expr:'Exactly two are false.', vars:['P','Q','R'], eval:v=>[v.P,v.Q,v.R].filter(x=>!x).length===2},
{expr:'Exactly two are true.', vars:['P','Q','R'], eval:v=>[v.P,v.Q,v.R].filter(x=>x).length===2},
{expr:'P is true only if Q or R is false.', vars:['P','Q','R'], eval:v=>(!v.P || (!v.Q || !v.R))},
{expr:'If R is true, then P and Q must be false.', vars:['P','Q','R'], eval:v=>(!v.R || (!v.P && !v.Q))},
{expr:'If P is false, Q and R must be true.', vars:['P','Q','R'], eval:v=>(v.P || (v.Q && v.R))},
{expr:'If Q is false, P or R must be true.', vars:['P','Q','R'], eval:v=>(v.Q || (v.P || v.R))},
{expr:'P and Q imply not R.', vars:['P','Q','R'], eval:v=>(!(v.P && v.Q) || !v.R)},

// --- ADVANCED (81‚Äì100) ---
{expr:'(P and not Q) implies (Q or R).', vars:['P','Q','R'], eval:v=>(!(v.P && !v.Q) || (v.Q || v.R))},
{expr:'(P or not R) implies (Q and R).', vars:['P','Q','R'], eval:v=>(! (v.P || !v.R) || (v.Q && v.R))},
{expr:'P iff (not Q implies R).', vars:['P','Q','R'], eval:v=>(v.P === (!v.Q || v.R))},
{expr:'P implies (Q implies R).', vars:['P','Q','R'], eval:v=>(!v.P || (!v.Q || v.R))},
{expr:'(P and Q) iff (Q and R).', vars:['P','Q','R'], eval:v=>((v.P && v.Q) === (v.Q && v.R))},
{expr:'(P or Q) iff (Q or R).', vars:['P','Q','R'], eval:v=>((v.P || v.Q) === (v.Q || v.R))},
{expr:'If exactly one of P or Q is true, then R must be true.', vars:['P','Q','R'], eval:v=>((v.P !== v.Q) ? v.R : true)},
{expr:'If all three are true, the statement is false.', vars:['P','Q','R'], eval:v=>!(v.P && v.Q && v.R)},
{expr:'If none are true, the statement is true.', vars:['P','Q','R'], eval:v=>(!(v.P || v.Q || v.R) ? true : false)},
{expr:'(P or Q) and not R.', vars:['P','Q','R'], eval:v=>((v.P || v.Q) && !v.R)},
{expr:'not(P xor Q).', vars:['P','Q'], eval:v=>(v.P === v.Q)},
{expr:'P xor (Q and R).', vars:['P','Q','R'], eval:v=>(v.P !== (v.Q && v.R))},
{expr:'(not P and Q) or R.', vars:['P','Q','R'], eval:v=>((!v.P && v.Q) || v.R)},
{expr:'If P or Q is false, R must be true.', vars:['P','Q','R'], eval:v=>((!v.P || !v.Q) ? v.R : true)},
{expr:'If R is true, then exactly one of P or Q must be true.', vars:['P','Q','R'], eval:v=>(!v.R || (v.P !== v.Q))},
{expr:'If P is true, not Q must be true.', vars:['P','Q'], eval:v=>(!v.P || !v.Q)},
{expr:'(P and Q) or R.', vars:['P','Q','R'], eval:v=>((v.P && v.Q) || v.R)},
{expr:'not(P or (Q xor R)).', vars:['P','Q','R'], eval:v=>!(v.P || (v.Q !== v.R))},
{expr:'P implies (not Q and not R).', vars:['P','Q','R'], eval:v=>(!v.P || (!v.Q && !v.R))},
{expr:'R implies (P xor Q).', vars:['P','Q','R'], eval:v=>(!v.R || (v.P !== v.Q))},

    ]
};

/* --- DOM references --- */
const DOM = {
    $: id => document.getElementById(id),
    get overlay() { return this.$('overlay'); },
    get playerCountInput() { return this.$('playerCount'); },
    get playersSetup() { return this.$('playersSetup'); },
    get avatarsRow() { return this.$('avatarsRow'); },
    get gameCard() { return this.$('gameCard'); },
    get playerName() { return this.$('playerName'); },
    get buffsArea() { return this.$('buffsArea'); },
    get gemsArea() { return this.$('gemsArea'); },
    get scoreArea() { return this.$('scoreArea'); },
    get expr() { return this.$('expr'); },
    get assign() { return this.$('assign'); },
    get timerCircle() { return this.$('timerCircle'); },
    get timerInner() { return this.$('timerInner'); },
    get indicators() { return this.$('indicators'); },
    get result() { return this.$('result'); },
    get log() { return this.$('log'); },
    get victoryBanner() { return this.$('victoryBanner'); },
    get victoryText() { return this.$('victoryText'); },
    get confetti() { return this.$('confetti'); },
    get startBtn() { return this.$('startBtn'); },
    get demoBtn() { return this.$('demoBtn'); },
    get backToWelcome() { return this.$('backToWelcome'); },
    get trueBtn() { return this.$('trueBtn'); },
    get falseBtn() { return this.$('falseBtn'); },
    get hintBtn() { return this.$('hintBtn'); },
    get skipBtn() { return this.$('skipBtn'); },
    get explainBtn() { return this.$('explainBtn'); },
    get closeVictory() { return this.$('closeVictory'); },
    get turnTime() { return this.$('turnTime'); },
    get targetGems() { return this.$('targetGems'); }
};

/* --- Game state --- */
const STATE = {
    players: [],
    currentPlayerIndex: 0,
    targetGems: 5,
    turnSeconds: 20,
    deck: [],
    deckIndex: 0,
    currentChallenge: null,
    timerRemaining: 0,
    timerTicker: null,
    muted: localStorage.getItem('logicQuest.muted') === 'true',
    gameOver: false,
    audioCtx: null
};

/* --- Utilities --- */
const utils = {
    clamp: (v,a,b) => Math.max(a, Math.min(b,v)),
    rand: n => Math.floor(Math.random() * n),
    shuffle: a => {
        for(let i=a.length-1; i>0; i--) {
            const j = Math.floor(Math.random()*(i+1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    },
    log: msg => {
        const time = (new Date()).toLocaleTimeString();
        DOM.log.insertAdjacentHTML('afterbegin', `<div class="mb-1"><strong style="color:var(--muted)">[${time}]</strong> ${msg}</div>`);
    },
    setResult: (text, tone) => {
        DOM.result.textContent = text || '';
        DOM.result.style.color = tone === 'ok' ? 'var(--ok)' : tone === 'bad' ? 'var(--bad)' : 'var(--muted)';
    },
    ensureAudio: () => {
        if (!STATE.audioCtx) {
            STATE.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    beep: (freq=440, dur=120, vol=0.06) => {
        if (STATE.muted) return;
        try {
            utils.ensureAudio();
            if (STATE.audioCtx.state === 'suspended') return;
            const o = STATE.audioCtx.createOscillator(), g=STATE.audioCtx.createGain();
            o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
            o.connect(g); g.connect(STATE.audioCtx.destination);
            o.start();
            setTimeout(() => o.stop(), dur);
        } catch(e) { console.error("Audio error:", e); }
    }
};

/* --- Build avatars --- */
function buildAvatars() {
    DOM.avatarsRow.innerHTML = '';
    CONFIG.AVATARS.forEach(av => {
        const b=document.createElement('button');
        b.type='button'; b.className='avatar'; b.textContent=av;
        b.addEventListener('click', () => {
            DOM.avatarsRow.querySelectorAll('.avatar').forEach(x => x.classList.remove('selected'));
            b.classList.add('selected');
        });
        DOM.avatarsRow.appendChild(b);
    });
    if (!DOM.avatarsRow.querySelector('.avatar.selected')) {
        DOM.avatarsRow.querySelector('.avatar')?.classList.add('selected');
    }
}

/* --- Build Player Setup --- */
function buildPlayersSetup() {
    DOM.playersSetup.innerHTML = '';
    const count = utils.clamp(Number(DOM.playerCountInput.value || 2), 1, 4);
    for (let i=0; i<count; i++) {
        const row=document.createElement('div');
        row.className='player-setup d-flex gap-2 align-items-center flex-wrap';

        const name=document.createElement('input');
        name.type='text'; name.value=`Player ${i+1}`; name.placeholder=`Player ${i+1}`; name.className='flex-grow-1';

        const buff1=document.createElement('select');
        const buff2=document.createElement('select');
        CONFIG.BUFFS.forEach(b => {
            const o1=document.createElement('option'); o1.value=b.key; o1.textContent=b.name; buff1.appendChild(o1);
            const o2=document.createElement('option'); o2.value=b.key; o2.textContent=b.name; buff2.appendChild(o2);
        });
        buff1.style.width='120px'; buff2.style.width='120px';

        row.appendChild(name); row.appendChild(buff1); row.appendChild(buff2);
        DOM.playersSetup.appendChild(row);
    }
}

/* --- Initialize deck --- */
function initDeck() {
    STATE.deck = utils.shuffle([...CONFIG.DECK]);
    STATE.deckIndex=0;
}

/* --- Draw question --- */
function drawQuestion() {
    if (STATE.deckIndex >= STATE.deck.length) initDeck();
    const q=STATE.deck[STATE.deckIndex++];
    const assign={};
    q.vars.forEach(k => assign[k]=Math.random() < 0.5);
    STATE.currentChallenge={...q, assign};
}

/* --- Timer functions --- */
function startTimer() {
    stopTimer();
    STATE.timerRemaining=STATE.turnSeconds;
    updateTimer();
    STATE.timerTicker=setInterval(() => {
        STATE.timerRemaining--;
        updateTimer();
        if (STATE.timerRemaining <= 0) {
            stopTimer();
            utils.log(`${STATE.players[STATE.currentPlayerIndex].name} timed out.`);
            utils.setResult('Time up ‚Äî auto-skip!', 'bad');
            setTimeout(() => nextTurn(true), 400);
        }
    }, 1000);
}

function stopTimer() {
    if (STATE.timerTicker) {
        clearInterval(STATE.timerTicker);
        STATE.timerTicker=null;
    }
}

function updateTimer() {
    DOM.timerInner.textContent=STATE.timerRemaining;
    const pct= (STATE.timerRemaining/STATE.turnSeconds)*360;
    DOM.timerCircle.style.background=`conic-gradient(var(--accent2) ${pct}deg, rgba(255,255,255,.04) ${pct}deg)`;
}

/* --- Render active player info --- */
function renderActivePlayer() {
    const p=STATE.players[STATE.currentPlayerIndex];
    if (!p) return;
    DOM.playerName.textContent=`${p.avatar || ''} ${p.name}`;
    DOM.scoreArea.textContent=`Score: ${p.score}`;

    // Buffs
    DOM.buffsArea.innerHTML='';
    p.buffKeys.forEach((bk, idx) => {
        const buff=CONFIG.BUFFS.find(b=>b.key===bk);
        if (!buff) return;
        const pill=document.createElement('div');
        pill.className='buff-pill'+(p.buffUsed[idx]?' used':'');
        pill.textContent=buff.name+(p.buffUsed[idx]?' (used)':'');
        pill.title=buff.desc;
        pill.addEventListener('click', () => {
            if (STATE.gameOver || p.buffUsed[idx]) return;
            if (STATE.players[STATE.currentPlayerIndex]===p) {
                activateBuff(p, idx);
            }
        });
        DOM.buffsArea.appendChild(pill);
    });

    // Gems
    DOM.gemsArea.innerHTML='';
    for (let i=0; i<STATE.targetGems; i++) {
        const g=document.createElement('div');
        g.className='gem'+(i<p.gems?' fill':'');
        DOM.gemsArea.appendChild(g);
    }

    renderIndicators();
}

/* --- Render indicators (dots) --- */
function renderIndicators() {
    DOM.indicators.innerHTML='';
    STATE.players.forEach((pl,i) => {
        const dot=document.createElement('div');
        dot.className='dot'+(i===STATE.currentPlayerIndex?' active':'');
        dot.title=pl.name;
        dot.addEventListener('click', () => {
            STATE.currentPlayerIndex=i;
            renderActivePlayer();
            if (STATE.currentChallenge) updateChallengeVis();
        });
        DOM.indicators.appendChild(dot);
    });
}

/* --- Update challenge display --- */
function updateChallengeVis() {
    const challenge=STATE.currentChallenge;
    if (!challenge) return;
    DOM.expr.textContent=challenge.expr;
    DOM.assign.textContent='Given: '+Object.entries(challenge.assign).map(([k,v])=>`${k}=${v?'True':'False'}`).join(', ');
    utils.setResult('');
    DOM.expr.style.transform='translateY(-6px)';
    setTimeout(() => { DOM.expr.style.transform=''; }, 120);
}

/* --- Buff activation --- */
function activateBuff(p, idx) {
    p.buffUsed[idx]=true;
    const key=p.buffKeys[idx];
    switch(key) {
        case 'negate':
            p.negateNext=true;
            utils.setResult(`${p.name} used üîÑ Negation ‚Äî next answer will flip`);
            utils.log(`${p.name} activated Negation`);
            utils.beep(780, 90, 0.06);
            break;
        case 'dash':
            utils.setResult(`${p.name} used ‚ö° Dash ‚Äî skipping your turn`);
            utils.log(`${p.name} activated Dash`);
            utils.beep(420, 80, 0.06);
            setTimeout(() => { nextTurn(true); }, 400);
            renderActivePlayer();
            return;
        case 'double':
            p.doubleNext=true;
            utils.setResult(`${p.name} used üíé Double ‚Äî next correct +2`);
            utils.log(`${p.name} activated Double`);
            utils.beep(980, 110, 0.06);
            break;
        case 'shield':
            p.shield=true;
            utils.setResult(`${p.name} used üõ°Ô∏è Shield ‚Äî next wrong protected`);
            utils.log(`${p.name} activated Shield`);
            utils.beep(640, 90, 0.06);
            break;
    }
    renderActivePlayer();
}

/* --- Check answer --- */
function checkAnswer(ans) {
    if (!STATE.currentChallenge || STATE.gameOver) return;
    stopTimer();

    const p=STATE.players[STATE.currentPlayerIndex];
    let finalAns=ans;

    if (p.negateNext) {
        finalAns=!ans;
        p.negateNext=false;
        utils.setResult(`${p.name} used Negation ‚Äî answer flipped`);
        utils.log(`${p.name} negated their answer`);
    }

    const correct=!!STATE.currentChallenge.eval(STATE.currentChallenge.assign);

    if (finalAns===correct) {
        let gain=1;
        let message=`${p.name} Correct! +1 Gem`;
        if (p.doubleNext) {
            gain=2;
            p.doubleNext=false;
            message=`${p.name} Correct! +${gain} Gems (Double)`;
        }
        utils.setResult(message,'ok');
        utils.log(`${p.name} correct +${gain}`);
        const oldGems=p.gems;
        p.gems=Math.min(STATE.targetGems,p.gems+gain);
        p.score++;
        animateGems(oldGems, p.gems);
        utils.beep(880,120,0.08);
    } else {
        if (p.shield) {
            utils.setResult(`${p.name} Wrong ‚Äî Shield protected you`, 'bad');
            p.shield=false;
            utils.log(`${p.name} saved by Shield`);
            utils.beep(200,90,0.05);
        } else {
            const oldGems=p.gems;
            p.gems=Math.max(0,p.gems-1);
            utils.setResult(`${p.name} Wrong! -1 Gem!`, 'bad');
            utils.log(`${p.name} answered wrongly, lost 1 gem`);
            animateGems(oldGems, p.gems);
            utils.beep(240,160,0.08);
        }
    }
    renderActivePlayer();
    if (p.gems>=STATE.targetGems) {
        onWin(p);
        return;
    }
    setTimeout(() => nextTurn(false), 800);
}

/* --- Animate gems --- */
function animateGems(oldCount, newCount) {
    const nodes=DOM.gemsArea.children;
    for (let i=0; i<nodes.length; i++) {
        const node=nodes[i];
        const isFill= i<newCount;
        node.classList.toggle('fill', isFill);
        if (i>=oldCount && i<newCount) {
            node.style.transform='scale(1.4)';
            setTimeout(() => { node.style.transform=''; }, 240);
        } else if (i<oldCount && i>=newCount) {
            node.style.transform='scale(0.8)';
            setTimeout(() => { node.style.transform=''; }, 240);
        }
    }
}

/* --- Next turn --- */
function nextTurn(skipped=false) {
    if (STATE.gameOver) return;
    STATE.currentPlayerIndex=(STATE.currentPlayerIndex+1)%STATE.players.length;
    drawQuestion();
    updateChallengeVis();
    renderActivePlayer();
    stopTimer();
    startTimer();
    maybeAiAct();
}

/* --- AI action --- */
function maybeAiAct() {
    const p=STATE.players[STATE.currentPlayerIndex];
    if (!p || !p.ai || STATE.gameOver) return;
    const evalCorrect=!!STATE.currentChallenge.eval(STATE.currentChallenge.assign);
    const willBeCorrect= Math.random() < (p.aiSkill || 0.7);
    const chosenAnswer=willBeCorrect?evalCorrect: !evalCorrect;

    setTimeout(() => {
        if (!STATE.gameOver && STATE.players[STATE.currentPlayerIndex]===p) {
            checkAnswer(chosenAnswer);
        }
    }, 700+ Math.random()*900);
}

/* --- Win / End game --- */
function spawnConfetti(count=130) {
    const colors=['#ffd166','#ff3d84','#6c58ff','#36d399','#fff4b8'];
    for (let i=0; i<count; i++) {
        const el=document.createElement('div');
        el.style.cssText= `
            position:absolute; left:${(Math.random()*100)}%; top:-10%;
            width:${(6+Math.random()*12)}px; height:${(8+Math.random()*18)}px;
            background:${colors[utils.rand(colors.length)]}; opacity:0.95; border-radius:2px;
            transform:rotate(${Math.random()*360}deg);
        `;
        const dur=1200+Math.random()*2000;
        el.style.transition=`top ${dur}ms linear, left ${dur}ms linear, transform ${dur}ms linear, opacity ${dur}ms linear`;
        DOM.confetti.appendChild(el);
        setTimeout(() => {
            el.style.top=(80+Math.random()*20)+'%';
            el.style.left= (Math.random()*100)+'%';
            el.style.transform=`rotate(${400+Math.random()*720}deg)`;
            el.style.opacity='0.9';
        }, 20);
        setTimeout(() => el.remove(), dur+300);
    }
}

function onWin(player) {
    STATE.gameOver=true;
    stopTimer();
    utils.setResult(`üèÜ ${player.name} wins with ${player.gems} Gems!`, 'ok');
    utils.log(`${player.name} won the game!`);

    utils.beep(523,150,0.08);
    setTimeout(() => utils.beep(659,150,0.08),150);
    setTimeout(() => utils.beep(784,300,0.08),300);
    spawnConfetti(200);
    DOM.victoryText.textContent=`üéâ ${player.name} is the Champion! üéâ`;
    DOM.victoryBanner.style.display='flex';
    saveWinner(player.name);
    disableControls(true);
}

function saveWinner(name) {
    const key='logicQuest.leaderboard.v1';
    const board= JSON.parse(localStorage.getItem(key)||'[]');
    board.unshift({name, date:new Date().toISOString()});
    localStorage.setItem(key, JSON.stringify(board.slice(0,20)));
}

function disableControls(d) {
    DOM.trueBtn.disabled=d;
    DOM.falseBtn.disabled=d;
    DOM.hintBtn.disabled=d;
    DOM.skipBtn.disabled=d;
    DOM.explainBtn.disabled=d;
}

/* --- Start game --- */
function collectSetupAndStart(isDemo=false) {
    STATE.turnSeconds= utils.clamp(Number(DOM.turnTime.value||20),5,60);
    STATE.targetGems= utils.clamp(Number(DOM.targetGems.value||5),1,9);
    STATE.players=[];

    if (isDemo) {
        // Demo players
        STATE.players.push({name:'Alice', avatar:'ü¶ä', buffKeys:['double','shield'], buffUsed:[false,false], gems:0, score:0, ai:false, negateNext:false, doubleNext:false, shield:false});
        STATE.players.push({name:'Bot', avatar:'üêâ', buffKeys:['negate','dash'], buffUsed:[false,false], gems:0, score:0, ai:true, aiSkill:0.7, negateNext:false, doubleNext:false, shield:false});
    } else {
        const selectedAvatar=DOM.avatarsRow.querySelector('.avatar.selected');
        const defaultAvatar= selectedAvatar? selectedAvatar.textContent: CONFIG.AVATARS[0];
        const actualRows= DOM.playersSetup.querySelectorAll('.player-setup');

        actualRows.forEach((r,i) => {
            const name=r.querySelector('input[type=text]').value || `Player ${i+1}`;
            const selects= r.querySelectorAll('select');
            const buff1=selects[0].value;
            const buff2=selects[1].value;
            STATE.players.push({
                name, avatar:defaultAvatar,
                buffKeys:[buff1,buff2], buffUsed:[false,false],
                gems:0, score:0, ai:false,
                negateNext:false, doubleNext:false, shield:false
            });
        });
        if (STATE.players.length===0) {
            collectSetupAndStart(true);
            return;
        }
    }

    // Hide overlay and start game
    DOM.overlay.classList.add('hidden');
    DOM.overlay.setAttribute('aria-hidden','true');
    DOM.overlay.style.display='none';
    DOM.gameCard.setAttribute('aria-hidden','false');

    disableControls(false);
    initDeck();
    drawQuestion();
    updateChallengeVis();
    STATE.currentPlayerIndex=0;
    STATE.gameOver=false;
    renderActivePlayer();
    stopTimer();
    startTimer();
    maybeAiAct();
    utils.log('Game started');
}

/* --- Back to welcome handler --- */
function backToWelcome() {
    stopTimer();
    DOM.overlay.classList.remove('hidden');
    DOM.overlay.setAttribute('aria-hidden','false');
    DOM.overlay.style.display='flex';
    DOM.gameCard.setAttribute('aria-hidden','true');
    disableControls(true);
    utils.log('Returned to welcome screen (game paused).');
}

/* --- Button handlers --- */
function handleShowHint() {
    if (!STATE.currentChallenge) return;
    let tip='Substitute variable values and simplify.';
    if (STATE.currentChallenge.expr.includes('‚áî')) tip='Biconditional: true when both sides match.';
    else if (STATE.currentChallenge.expr.includes('‚áí')) tip='Implication: false only if left true and right false.';
    else if (STATE.currentChallenge.expr.includes('‚äï')) tip='Exclusive OR: true when exactly one true.';
    utils.setResult('üí° '+tip,'muted');
    utils.log('Hint: '+tip);
}
function handleExplain() {
    if (!STATE.currentChallenge) return;
    const correct=!!STATE.currentChallenge.eval(STATE.currentChallenge.assign);
    let explanation=`The expression **${STATE.currentChallenge.expr}** with **${Object.entries(STATE.currentChallenge.assign).map(([k,v])=>`${k}=${v?'True':'False'}`).join(', ')}** evaluates to **${correct?'True':'False'}**.`;
    utils.setResult(explanation,'muted');
    utils.log('Explanation requested');
}
function handleSkip() {
    utils.log(`${STATE.players[STATE.currentPlayerIndex].name} skipped.`);
    utils.setResult('Skipped','muted');
    nextTurn(true);
}
function handleKeyPress(e) {
    if (DOM.overlay.style.display!=='none' && !DOM.overlay.classList.contains('hidden')) {
        if (e.key==='Enter') { e.preventDefault(); DOM.startBtn.click(); }
        return;
    }
    if (document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='SELECT' || document.activeElement.getAttribute('tabindex')==='0')) return;
    const k=e.key.toLowerCase();
    if (k==='t') DOM.trueBtn.click();
    else if (k==='f') DOM.falseBtn.click();
    else if (k==='h') DOM.hintBtn.click();
    else if (k==='s') DOM.skipBtn.click();
    else if (k==='m') {
        STATE.muted= !STATE.muted;
        localStorage.setItem('logicQuest.muted', STATE.muted?'true':'false');
        utils.log(STATE.muted?'Muted':'Unmuted');
    }
}

/* --- Initialization --- */
function init() {
    buildAvatars();
    buildPlayersSetup();

    DOM.startBtn.addEventListener('click', () => { collectSetupAndStart(false); });
    DOM.demoBtn.addEventListener('click', () => { collectSetupAndStart(true); });
    DOM.playerCountInput.addEventListener('input', buildPlayersSetup);
    DOM.trueBtn.addEventListener('click', () => { checkAnswer(true); });
    DOM.falseBtn.addEventListener('click', () => { checkAnswer(false); });
    DOM.hintBtn.addEventListener('click', handleShowHint);
    DOM.explainBtn.addEventListener('click', handleExplain);
    DOM.skipBtn.addEventListener('click', handleSkip);
    DOM.backToWelcome.addEventListener('click', () => { backToWelcome(); });
    DOM.closeVictory.addEventListener('click', () => { DOM.victoryBanner.style.display='none'; });
    document.addEventListener('keydown', handleKeyPress);

    // Unlock audio on first click
    document.addEventListener('click', () => {
        try {
            utils.ensureAudio();
            if (STATE.audioCtx && STATE.audioCtx.state==='suspended') {
                STATE.audioCtx.resume().then(() => { utils.log('Audio unlocked'); });
            }
        } catch(e) {}
    }, {once:true});

    window._logicQuest={STATE, collectSetupAndStart, spawnConfetti};
}

init();

</script>
</body>
</html>
